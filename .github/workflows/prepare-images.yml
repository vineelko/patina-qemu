# A reusable workflow to prepare OS boot images for Linux and Windows
#
# This action first checks the cache for an existing prepared image based on the checksum of the
# base image. If not found, it downloads the base image, prepares it for OS boot testing, and
# uploads the prepared image as an artifact for use in subsequent jobs. The retention date for the
# published artifact is set to 1 day, as the actual storing of the prepared image is handled by the
# cache.
#
##
# Copyright (c) Microsoft Corporation.
#
# SPDX-License-Identifier: BSD-2-Clause-Patent
##
name: "Prepare OS Boot Image"

on:
  workflow_call:
    inputs:
      image-url:
        description: 'URL of the base cloud image'
        required: true
        type: string
      artifact-name:
        description: 'Name of the artifact to upload the prepared images as'
        required: true
        type: string

env:
  IMG: base.img
  DISK_IMAGE: image.qcow2
  SEED_ISO: seed.iso

jobs:
  build-ubuntu-images:
    name: Prepare Ubuntu Boot Image

    if: ${{ contains(inputs.artifact-name, 'ubuntu') }}

    runs-on: ubuntu-latest

    steps:
      - name: Download image checksum
        id: checksum
        run: |
          img_url=${{ inputs.image-url }}
          img_name=$(basename "${img_url}")
          checksum_url="${img_url%/*}/SHA256SUMS"

          img_sha=$(curl -fsSL "${checksum_url}" | awk -v f="*${img_name}" '$2==f {print $1}')

          [ -n "${img_sha}" ] || (echo "Failed to retrieve image checksum" >&2; exit 1)

          echo "sha=${img_sha}" >> $GITHUB_OUTPUT
      
      - name: Cache Ubuntu cloud image
        id: cache
        uses: actions/cache@v4
        with:
          path: artifacts
          key: ${{ inputs.artifact-name }}-${{ steps.checksum.outputs.sha }}

      - name: Install Dependencies
        if: steps.cache.outputs.cache-hit != 'true'
        run: |
          sudo apt update
          sudo apt install -y qemu-system-x86 qemu-system-aarch64 qemu-utils ovmf curl cloud-image-utils
      
      - name: Download Ubuntu IMG
        if: steps.cache.outputs.cache-hit != 'true'
        run: |
          curl -L "${{ inputs.image-url }}" -o "${{ env.IMG }}"

      - name: Create QCOW2 Image
        if: steps.cache.outputs.cache-hit != 'true'
        run: |
          # Create the differential qcow2
          qemu-img create -f qcow2 -b "${{ env.IMG }}" -F qcow2 "${{ env.DISK_IMAGE }}"

          # Flatten it into a standalone qcow2
          qemu-img convert -O qcow2 "${{ env.DISK_IMAGE }}" "${{ env.DISK_IMAGE }}-flat.qcow2"

          # Use the flattened image for booting / uploading
          mv "${{ env.DISK_IMAGE }}-flat.qcow2" "${{ env.DISK_IMAGE }}"
                
      - name: Make seed.iso
        if: steps.cache.outputs.cache-hit != 'true'
        run: |
          mkdir seed
          echo "instance-id: ci-vm-$(date +%s)" > seed/meta-data
          echo "#cloud-config" > seed/user-data
          echo "power_state:" >> seed/user-data
          echo "  mode: poweroff" >> seed/user-data
          echo "  timeout: 1" >> seed/user-data
          echo "  condition: True" >> seed/user-data

      - name: Build seed ISO (cloud-init)
        if: steps.cache.outputs.cache-hit != 'true'
        run: |
          cloud-localds "${{ env.SEED_ISO }}" seed/user-data seed/meta-data
      
      - name: Move to artifacts directory
        if: steps.cache.outputs.cache-hit != 'true'
        run: |
          mkdir artifacts
          mv "${{ env.DISK_IMAGE }}" artifacts/
          mv "${{ env.SEED_ISO }}" artifacts/
      
      - name: Publish Artifacts
        uses: actions/upload-artifact@v6
        with:
          name: ${{ inputs.artifact-name }}
          retention-days: 1
          path: |
            artifacts/${{ env.DISK_IMAGE }}
            artifacts/${{ env.SEED_ISO }}
            
  build-windows-images:
    name: Prepare Windows Boot Image

    if: ${{ contains(inputs.artifact-name, 'windows') }}

    # Need to run on the appropriate architecture so we generate a valid shutdown.exe
    runs-on: ${{ contains(inputs.artifact-name, 'aarch64') && 'windows-11-arm' || 'windows-latest' }}

    env:
      ARCHITECTURE: ${{ contains(inputs.artifact-name, 'aarch64') && 'arm64' || 'x64' }}

    steps:
      - name: Download Windows Validation OS image and checksum
        id: checksum
        run: |
          Invoke-WebRequest -Uri "${{ inputs.image-url }}" -OutFile "${{ env.IMG }}"

          $hash = (Get-FileHash -Path "${{ env.IMG }}" -Algorithm SHA256).Hash
          Write-Host "Downloaded image SHA256: $hash" 

          Add-Content -Path $env:GITHUB_OUTPUT -Value "sha=$hash"
      
      - name: Cache Windows cloud image
        id: cache
        uses: actions/cache@v4
        with:
          path: artifacts
          key: ${{ inputs.artifact-name }}-${{ steps.checksum.outputs.sha }}

      - name: Install Dependencies
        if: steps.cache.outputs.cache-hit != 'true'
        run: |
          choco install -y qemu
          Install-Module -Name PS2EXE -Scope CurrentUser -Force
  
      - name: Setup .NET
        if: steps.cache.outputs.cache-hit != 'true'
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: 6.0.x # 6.0.0 is specifically required for the WVOS Image Builder CLI.

      - name: Prepare Shutdown EXE
        if: steps.cache.outputs.cache-hit != 'true'
        id: shutdown-exe
        run: |
          $script = 'Stop-Computer -Force'
          $scriptPath = "shutdown.ps1"
          $exePath = "shutdown.exe"
          
          Set-Content -Path $scriptPath -Value $script -Encoding ASCII

          Invoke-PS2EXE $scriptPath $exePath -noConsole -icon "$null"
          Write-Host "Shutdown EXE created at $env:GITHUB_WORKSPACE\$exePath"
      
      - name: Mount Image and run OS Builder
        if: steps.cache.outputs.cache-hit != 'true'
        run: |
          $mountResult = Mount-DiskImage -ImagePath (Get-Item $env:IMG).FullName -PassThru
          $driveLetter = ($mountResult | Get-Volume).DriveLetter
          Write-Host "Mounted ISO at ${driveLetter}:\"

          $cliPath = Join-Path "${driveLetter}:\" "ValidationOSImageBuilder\$env:ARCHITECTURE\ValidationOSImageBuilderCLI.exe"

          $exePath = Join-Path "$env:GITHUB_WORKSPACE" "shutdown.exe"

          # We need the powershell and provisioning packages to be able to run our shutdown executable.
          & $cliPath -g -if vhdx -bt InternalDisk -sc "$exePath" -f powershell -f provisioning -o $env:GITHUB_WORKSPACE
      
      - name: Convert to qcow2
        if: steps.cache.outputs.cache-hit != 'true'
        run: |
          $vhdxPath = Get-ChildItem -Path $env:GITHUB_WORKSPACE -Filter *.vhdx -Recurse -File | Select-Object -First 1
          Write-Host "Converting VHDX at $($vhdxPath.FullName) to QCOW2"

          & "C:\Program Files\qemu\qemu-img.exe" convert -O qcow2 $($vhdxPath.FullName) "$env:GITHUB_WORKSPACE\${{ env.DISK_IMAGE }}"
          Write-Host "QCOW2 image created at $env:GITHUB_WORKSPACE\${{ env.DISK_IMAGE }}"
      
      - name: Move to artifacts directory
        if: steps.cache.outputs.cache-hit != 'true'
        run: |
          mkdir artifacts
          mv "${{ env.DISK_IMAGE }}" artifacts/
      
      - name: Publish Artifacts
        uses: actions/upload-artifact@v6
        with:
          name: ${{ inputs.artifact-name }}
          retention-days: 1
          path: |
            artifacts/${{ env.DISK_IMAGE }}
